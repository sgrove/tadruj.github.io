Knowledge

In strict evaluation langauges the arguments get eveluated first and then functions get applied.

In lazy languages, all the functions are applied and promises are being created and then arguments get evaluated.

In lazy evaluation you're writing a program, which creates a program to evaluate. So it's kind of meta programming from the start. You set the execution start conditions with a right pattern match or a guard and this is how you actually start the execution.

The guards and patterns get evaluated with priority to direct the flow of the program and they are the basic tools to meta program.

The best way to learn functional programming is to stick with your language and do programming without side effects. Or not take a language, where you have to take care of lazy evaluation too. It's two different concepts and learning both of the at the same time is a bad idea.

type signature = type declaration = fun Num a => a -> a -> a
function expression fun x = x+1

polymorphic function takes different types or arguments [a] -> [a]

In language like Haskell, where you have to think how will you convert from integer to float, you are not left with enough of brain power to think about higher level concepts.

