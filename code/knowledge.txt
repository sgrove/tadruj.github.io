Knowledge

In strict evaluation langauges the arguments get eveluated first and then functions get applied.

In lazy languages, all the functions are applied and promises are being created and then arguments get evaluated.

In lazy evaluation you're writing a program, which creates a program to evaluate. So it's kind of meta programming from the start. You set the execution start conditions with a right pattern match or a guard and this is how you actually start the execution.

The guards and patterns get evaluated with priority to direct the flow of the program and they are the basic tools to meta program.

The best way to learn functional programming is to stick with your language and do programming without side effects. Or not take a language, where you have to take care of lazy evaluation too. It's two different concepts and learning both of the at the same time is a bad idea.

type signature = type declaration = fun Num a => a -> a -> a
function expression fun x = x+1

polymorphic function takes different types or arguments [a] -> [a]

In language like Haskell, where you have to think how will you convert from integer to float, you are not left with enough of brain power to think about higher level concepts.

OCaml

we didn't get rid of Currying from Haskell :{
OCaml requires that both branches of an if statement have the same type

Basis of functional programming are really higher order functions, static
typing, algebraic datatypes and pattern matching.

Racket is a typed Scheme

Haskel has too much other stuff like lazy evaluation and monads




